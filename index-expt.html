<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="shortcut icon" type="image/x-icon" href="./static/site/img/favicon.ico">

  <title>expt</title>

  <style type="text/css">
    * {
      margin: 0;
      padding: 0;
    }

    html {
      font-size: 62.5%;
    }

    body {
      font-size: 1.4em;
      font-family: "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif;
      overflow: hidden;
      background-color: #000;
    }

    canvas {
      display: block;
    }
  </style>

</head>

<body>

</body>

<!-- three.js -->
<script type="importmap">
  {
    "imports": {
      "three": "./static/build.181/three.module.js",
      "three/libs/": "./static/libs/",
      "three/controls/": "./static/controls/"
    }
  }
</script>

<script type="module">

  import * as THREE from 'three';
  import { OrbitControls } from "three/controls/OrbitControls.js";

  window.addEventListener("load", () => {

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // コントロール
    const controls = new OrbitControls(camera, renderer.domElement);
    camera.position.set(0, 0, 50);
    controls.update();

    // GeoJSONデータの読み込み
    const geojsonData = {
      "type": "FeatureCollection",
      "features": [
        {
          "type": "Feature",
          "properties": {},
          "geometry": {
            "type": "Point",
            "coordinates": [139.767052, 35.681167] // 東京駅の緯度・経度
          }
        },
        {
          "type": "Feature",
          "properties": {},
          "geometry": {
            "type": "LineString",
            "coordinates": [
              [139.70, 35.65],
              [139.80, 35.70],
              [139.75, 35.75]
            ]
          }
        },
        {
          "type": "Feature",
          "properties": {},
          "geometry": {
            "type": "Polygon",
            "coordinates": [
              [
                [139.70, 35.70],
                [139.75, 35.65],
                [139.80, 35.70],
                [139.70, 35.70]
              ]
            ]
          }
        }
      ]
    };

    // GeoJSONの中心座標を計算
    let minLon = Infinity, maxLon = -Infinity;
    let minLat = Infinity, maxLat = -Infinity;

    geojsonData.features.forEach(feature => {
      const coords = feature.geometry.coordinates;
      const type = feature.geometry.type;

      if (type === 'Point') {
        minLon = Math.min(minLon, coords[0]);
        maxLon = Math.max(maxLon, coords[0]);
        minLat = Math.min(minLat, coords[1]);
        maxLat = Math.max(maxLat, coords[1]);
      } else if (type === 'LineString') {
        coords.forEach(coord => {
          minLon = Math.min(minLon, coord[0]);
          maxLon = Math.max(maxLon, coord[0]);
          minLat = Math.min(minLat, coord[1]);
          maxLat = Math.max(maxLat, coord[1]);
        });
      } else if (type === 'Polygon') {
        coords[0].forEach(coord => {
          minLon = Math.min(minLon, coord[0]);
          maxLon = Math.max(maxLon, coord[0]);
          minLat = Math.min(minLat, coord[1]);
          maxLat = Math.max(maxLat, coord[1]);
        });
      }
    });

    const centerLon = (minLon + maxLon) / 2;
    const centerLat = (minLat + maxLat) / 2;

    console.log('Center:', centerLon, centerLat);
    console.log('Bounds:', { minLon, maxLon, minLat, maxLat });

    // 緯度・経度をthree.jsのXYZ座標に変換（中心を原点に）
    function projectCoordinates(longitude, latitude) {
      const scale = 100; // スケール調整（小さめに設定）
      const x = (longitude - centerLon) * scale;
      const y = (latitude - centerLat) * scale;
      const z = 0;
      return new THREE.Vector3(x, y, z);
    }

    // GeoJSONデータをthree.jsオブジェクトに変換
    geojsonData.features.forEach(feature => {
      const geometryType = feature.geometry.type;
      const coordinates = feature.geometry.coordinates;

      if (geometryType === 'Point') {
        const projectedCoords = projectCoordinates(coordinates[0], coordinates[1]);
        const pointGeometry = new THREE.SphereGeometry(1, 16, 16);
        const pointMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const pointMesh = new THREE.Mesh(pointGeometry, pointMaterial);
        pointMesh.position.copy(projectedCoords);
        scene.add(pointMesh);
        console.log('Point added at:', projectedCoords);
      } else if (geometryType === 'LineString') {
        const points = [];
        coordinates.forEach(coord => {
          const projectedCoords = projectCoordinates(coord[0], coord[1]);
          points.push(projectedCoords);
        });
        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff, linewidth: 2 });
        const line = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(line);
        console.log('LineString added with', points.length, 'points');
      } else if (geometryType === 'Polygon') {
        const outerRing = coordinates[0];
        const points = [];
        outerRing.forEach(coord => {
          const projectedCoords = projectCoordinates(coord[0], coord[1]);
          points.push(projectedCoords);
        });
        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2 });
        const line = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(line);
        console.log('Polygon added with', points.length, 'points');
      }
    });

    // グリッドヘルパーを追加（デバッグ用）
    const gridHelper = new THREE.GridHelper(100, 10, 0x444444, 0x222222);
    gridHelper.rotation.x = Math.PI / 2;
    scene.add(gridHelper);

    // 軸ヘルパーを追加（デバッグ用）
    const axesHelper = new THREE.AxesHelper(20);
    scene.add(axesHelper);

    // ウィンドウリサイズ対応
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // アニメーションループ
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    console.log('Scene initialized');
  });
</script>

</html>